/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/

import { writeCodeToFile, autoGeneratedFileHeader } from './generateUtils';
import got from 'got';
import { JSONSchema4 } from 'json-schema';
import custom from './dapCustom';

/* eslint-disable @typescript-eslint/no-non-null-assertion */

function toTitleCase(s: string) {
  return s[0].toUpperCase() + s.substr(1);
}

function hasRef(definition: JSONSchema4): definition is JSONSchema4 & { $ref: JSONSchema4 } {
  return typeof definition === 'object' && !!definition.$ref;
}

async function generate() {
  const { body: standard } = await got<JSONSchema4>(
    'https://raw.githubusercontent.com/microsoft/debug-adapter-protocol/gh-pages/debugAdapterProtocol.json',
    { responseType: 'json' },
  );
  const result: string[] = [];

  const headers: string[] = [];

  // result.push(autoGeneratedFileHeader('generate-dap-api.js'));
  // result.push(`import * as E from './error';`);
  // result.push(``);
  // result.push(`export namespace Dap {`);
  // result.push(`export type Error = E.Error;`);
  // result.push(`export type Message = E.Message;`);
  // result.push(`export type integer = number;`);
  // result.push(``);



  function appendText(text?: string) {
    if (!text) return;
    result.push(`    /**`);
    for (const line of text.split('\n')) result.push(`    * ${line}`);
    result.push(`    */`);
  }

  function createSeparator() {
    let first = true;
    return function () {
      if (!first) result.push(``);
      first = false;
    };
  }

  const defs = { ...standard.definitions, ...custom.definitions };

  function definition(name: string) {
    return name.substring('#/definitions/'.length);
  }

  const types: string[] = [];
  const typesSet = new Set<string>();



  function generateType(prop: JSONSchema4, name?: string): string {
    const valueEnum = ((prop as unknown) as { _enum?: string[] })._enum;
    if (valueEnum) {
      //return `${valueEnum.map(value => `'${value}'`).join(' | ')}`;

      const enumName = toTitleCase(`${name}Enum`);
      if (!typesSet.has(enumName)) {
        types.push(enumName);
        typesSet.add(enumName)

        defs[enumName] = (<JSONSchema4>{
          type: 'enum' as any,
          enum: [...valueEnum],
        });
      }

      //return 'JToken';
      return enumName;
    }

    if (prop['$ref']) {
      const def = definition(prop['$ref']);
      if (!typesSet.has(def)) {
        types.push(def);
        typesSet.add(def);
      }
      return `${def}`;
    }

    if (Array.isArray(prop.type)) {
      //return `${prop.type.map(type => generateType({ type })).join(' | ')}`;



      return 'JToken';
    }

    if (prop.type === 'array') {
      const subtype = prop.items ? generateType(prop.items as JSONSchema4, name) : 'any';
      return `${subtype}[]`;
    }

    if (prop.type === 'integer') {
      return 'int';
    }

    if (prop.type === 'number') {
      return 'double'
    }

    if (prop.type === 'boolean') {
      return 'bool';
    }

    if (prop.type === 'any') {
      return 'object';
    }


    if (!prop.type) {
      throw new Error(`Expected prop type in ${JSON.stringify(prop)}`);
    }

    return prop.type;
  }

  function appendProps(
    props: { [k: string]: JSONSchema4 },
    required?: Iterable<string> | false | null,
  ) {
    const requiredSet = new Set(required || []);
    const propSeparator = createSeparator();
    for (const name in props) {
      const prop = props[name];
      propSeparator();
      appendText(prop.description);
      const generatedType = generateType(prop, name);
      result.push(`    [JsonProperty("${name}")]`);
      result.push(`    public ${generatedType} ${toTitleCase(name)} { get; set; }`);
    }
  }

  function getExtends(def: JSONSchema4) {
    const refs = def
      .allOf!.filter(hasRef)
      .map(x => definition(x.$ref))
      .join(', ');

    return ' : ' + refs;
  }

  const stubs: { type: string; name: string; value: JSONSchema4 }[] = [];
  const interfaceSeparator = createSeparator();

  interfaceSeparator();

  const apiSeparator = createSeparator();

  // ============================ API ==============================

  result.push(`public partial interface Api {`);
  for (const name in defs) {
    const def = defs[name];
    if (!def.allOf) {
      continue;
    }
    const ref = def.allOf.find(hasRef);
    const desc = def.allOf.find(parent => !hasRef(parent)) as JSONSchema4 | undefined;
    if (!ref || !desc) {
      continue;
    }

    if (ref.$ref === '#/definitions/Event') {
      apiSeparator();
      appendText(desc.description);
      result.push(`event EventHandler<${name}Args> ${desc.properties!.event.enum![0]};`);
      stubs.push({
        type: 'event',
        name: `${name}Args`,
        value: desc.properties?.body || { properties: {} },
      });
    }
    if (ref['$ref'] === '#/definitions/Request') {
      const short = desc.properties!.command.enum![0];
      const title = toTitleCase(String(short));
      apiSeparator();
      //appendText(desc.description);
      // result.push(``)
      // result.push(
      //   `on(request: '${short}', handler: (params: ${title}Params) => Promise<${title}Result | Error>): () => void;`,
      // );
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const args = desc.properties?.arguments ? desc.properties.arguments.$ref! : '#/definitions/';
      stubs.push({
        type: 'params',
        name: `${title}Args`,
        value: defs[definition(args)] || { properties: {} },
      });
      stubs.push({
        type: 'result',
        name: `${title}Result`,
        value: defs[`${name.substring(0, name.length - 'Request'.length)}Response`],
      });

      appendText(desc.description);
      result.push(`ValueTask<${title}Result> ${title}(${title}Args args);`);
    }
  }
  result.push(`}`);

  // ============================ TYPES ==============================

  stubs.sort((a, b) => (a.name < b.name ? -1 : 1));
  for (const type of stubs) {
    interfaceSeparator();
    result.push(`public partial class ${type.name} {`);
    if (type.type === 'result') {
      const desc = type.value.allOf!.find(parent => !parent['$ref'])!;
      type.value = desc.properties ? desc.properties.body : { properties: {} };
      while (type.value['$ref']) type.value = defs[definition(type.value['$ref'])];
    }
    appendProps(type.value.properties!, type.value.required);
    result.push(`}`);
  }

  while (types.length) {
    const type = types.pop()!;
    const def = defs[type];
    interfaceSeparator();
    appendText(def.description);
    if (def.type && (def.type as any) === 'enum') {
      result.push(`public enum ${type} {`);
      result.push(def.enum!.map(x => `    [EnumMember(Value = "${x as any}")]\r\n    ${toTitleCase(x as any)}`).join(',\r\n'));
      result.push('}');
    }
    else if (def.type === 'string' && def.enum) {
      result.push(`public enum ${type} {`);
      result.push(def.enum!.map(x => `    [EnumMember(Value = "${x as any}")]\r\n    ${toTitleCase(x as any)}`).join(',\r\n'));
      result.push('}');
    }
    else if (def.type && def.type !== 'object') {
      result.push(`export type ${type} = ${def.type};`);
      //headers.push(`using ${type} = ${def.type === 'string' ? 'System.String' : def.type};`);
    }
    else {
      result.push(`public partial class ${type} ${def.allOf ? getExtends(def) : ''} {`);

      if (def.allOf) {
        // def extends some other interface(s)
        const ownDescription = def.allOf.find(parent => !hasRef(parent))!;
        appendProps(ownDescription.properties!, ownDescription.required);
      } else {
        appendProps(def.properties!, def.required);
      }
      result.push(`}`);
    }
  }

  result.push(`}`);




  writeCodeToFile([...headers, ...result].join('\n'), 'src/dap/api.cs');



}

generate().catch(console.error);
